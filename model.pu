"""
model.py â€“ Core calculation engine for the Private Equity Portfolio Model.
Implements:
- calculate_distributions()
- calculate_irr() via bisection
- build_cash_flows()
- validate_inputs()
"""

from typing import Dict, List, Tuple

def calculate_distributions(total_called: float, target_moic: float, holding_period: int) -> Dict[int, float]:
    """
    Generate a realistic time-phased distribution schedule that sums to target_moic * total_called.
    Distributions begin in year 4. Tail length and plateau scale with MOIC to keep IRR in realistic bands.
    """
    total_value = total_called * target_moic
    dist_start_year = 4  # distributions begin in year 4

    # Longer tails for higher MOIC to avoid artificially high IRR
    if target_moic <= 2.1:
        tail_extra = 3
        plateau = 0.11
    elif target_moic <= 2.6:
        tail_extra = 6
        plateau = 0.10
    else:
        tail_extra = 8
        plateau = 0.09

    dist_end_year = holding_period + tail_extra
    dist_years = dist_end_year - dist_start_year + 1
    if dist_years < 1:
        dist_years = 1
        dist_end_year = dist_start_year

    distributions: Dict[int, float] = {}
    total_weight = 0.0

    ramp_floor = 0.02
    ramp_top = plateau
    taper_floor = 0.04

    for i in range(dist_years):
        year = dist_start_year + i
        progress = i / max(1, dist_years - 1)

        if progress < 0.25:
            # ramp from 2% up to plateau
            weight = ramp_floor + (progress / 0.25) * (ramp_top - ramp_floor)
        elif progress < 0.80:
            weight = plateau
        else:
            # taper from plateau down to 4%
            tail_prog = (progress - 0.80) / 0.20
            weight = plateau - tail_prog * (plateau - taper_floor)

        distributions[year] = weight
        total_weight += weight

    # normalize to target total value
    for y in list(distributions.keys()):
        distributions[y] = (distributions[y] / total_weight) * total_value

    return distributions